{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/carlos.dias/Documents/Apps/mui_CHECKLIST/src/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\r\n\r\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\r\n\r\nexport const prisma = globalForPrisma.prisma || new PrismaClient();\r\nexport default prisma;\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAEjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;uCACjD;AACf,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/carlos.dias/Documents/Apps/mui_CHECKLIST/src/auth.ts"],"sourcesContent":["import NextAuth, { AuthError } from 'next-auth';\nimport Credentials from 'next-auth/providers/credentials';\nimport type { Provider } from 'next-auth/providers';\nimport { compare } from 'bcryptjs';\nimport prisma from '@/prisma';\nimport * as jose from 'jose';\n\ninterface CustomUser {\n  id: string;\n  role: string;\n  username: string;\n  email: string;\n  name: string;\n  image: string | null;\n}\n\n/*\n// Generate a secure key (in production, use environment variables)\nexport const SECRET_KEY = new TextEncoder().encode(\n  process.env.NEXTAUTH_SECRET\n);\n// JOSE encryption configuration\nconst ENCRYPTION_ALG = 'A256GCM'; // AES-GCM with 256-bit key\nconst KEY_ALG = 'dir';           // Direct encryption with shared key\n/**\n * Custom JWT Encoding function using JOSE\n * @param token - The token to encrypt\n * /\nexport async function encodeJWT({ token }: { token: jose.JWTPayload }): Promise<string> {\n  try {\n    // Convert token to a string for encryption\n    const tokenString = JSON.stringify(token);\n\n    // Create a JWE (JSON Web Encryption)\n    const jwe = await new jose.CompactEncrypt(\n      new TextEncoder().encode(tokenString)\n    )\n      .setProtectedHeader({\n        alg: KEY_ALG,\n        enc: ENCRYPTION_ALG\n      })\n      .encrypt(SECRET_KEY);\n\n    return jwe;\n  } catch (error) {\n    console.error(\"Error encoding JWT:\", error);\n    throw new Error(\"Failed to encode JWT\");\n  }\n}\n\n/**\n * Custom JWT Decoding function using JOSE\n * @param token - The encrypted token to decrypt\n * /\nexport async function decodeJWT(token: string): Promise<jose.JWTPayload> {\n  try {\n    // Decrypt the JWE\n    const { plaintext } = await jose.compactDecrypt(token, SECRET_KEY);\n\n    // Convert decrypted data back to an object\n    const decodedToken = JSON.parse(new TextDecoder().decode(plaintext));\n    return decodedToken;\n  } catch (error) {\n    console.error(\"Error decoding JWT:\", error);\n    throw new Error(\"Failed to decode JWT\");\n  }\n}\n// Example of using custom payloads in the token\nexport interface CustomJWT extends jose.JWTPayload {\n  user?: {\n    id: string;\n    name?: string;\n    email?: string;\n    role?: string;\n  };\n  customClaims?: {\n    permissions?: string[];\n    metadata?: Record<string, any>;\n  };\n}\n*/\n\nconst providers: Provider[] = [\n  Credentials({\n    credentials: {\n      username: { label: \"Username\", type: \"text\" },\n      password: { label: \"Password\", type: \"password\" }\n    },\n    async authorize(c) {\n      if (!c?.username || !c?.password) throw new AuthError(\"Campos não preenchidos!\");\n      const { username, password } = c as { username: string, password: string };\n      // Buscar usuário\n      const user = await prisma.user.findUnique({ where: { username } });\n\n      if (!user || !user.password || !user?.isActive)\n        throw new AuthError(\"Credenciais inválidas!\");\n      // Verificar senha\n      if (!(await compare(password, user.password)))\n        throw new AuthError(\"Credenciais inválidas!\");\n      return {\n        id: user.id,\n        username: user.username,\n        email: user.email,\n        name: user.name,\n        role: user.role,\n      };\n    },\n  }),\n];\n\n\nif (!process.env.AUTH_SECRET) {\n  console.warn('Missing environment variable \"AUTH_SECRET\"');\n}\nif (!process.env.DATABASE_URL) {\n  console.warn('Missing environment variable \"DATABASE_URL\"');\n}\n\nexport const providerMap = providers.map((provider) => {\n  if (typeof provider === 'function') {\n    const providerData = provider();\n    return { id: providerData.id, name: providerData.name };\n  }\n  return { id: provider.id, name: provider.name };\n});\n\nexport const { handlers, auth, signIn, signOut } = NextAuth({\n  providers,\n  secret: process.env.AUTH_SECRET,\n  pages: {\n    signIn: '/auth/signin',\n  },\n  callbacks: {\n    authorized({ auth: session, request: { nextUrl } }) {\n      const isLoggedIn = !!session?.user;\n      const isPublicPage = nextUrl.pathname.startsWith('/');\n\n      if (isPublicPage || isLoggedIn) {\n        return true;\n      }\n\n      return false; // Redirect unauthenticated users to login page\n    },\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n        token.username = (user as CustomUser).username;\n        token.role = (user as CustomUser).role ?? \"\";\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (token) {\n        session.user.id = token.id as string;\n        session.user.username = token.username as string;\n        session.user.role = token.role as string;\n      }\n      return session;\n    }\n  },\n  events: {\n    async signIn({ user }) {\n      console.log(`Usuário logado: ${(user as CustomUser).username}`);\n    },\n    async signOut({ token }: any) {\n      // Remover tokens ao fazer logout\n      await prisma.account.deleteMany({\n        where: {\n          userId: token.id as string,\n          provider: \"credentials\",\n        },\n      });\n      console.log(`Usuário deslogado: ${token.username}`);\n    },\n  },\n  session: {\n    strategy: \"jwt\"\n  },\n  logger: {\n    error(code, ...message) { },\n    warn(code, ...message) { },\n    debug(code, ...message) { },\n  },\n});\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 297, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/carlos.dias/Documents/Apps/mui_CHECKLIST/src/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import { handlers } from '../../../../auth';\n\nexport const { GET, POST } = handlers;\n"],"names":[],"mappings":";;;;AAAA;;AAEO,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,6GAAA,CAAA,WAAQ","debugId":null}}]
}